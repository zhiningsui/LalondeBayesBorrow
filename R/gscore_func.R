#' Simulate g-scores with Zero Inflation
#'
#' This function generates g-scores by simulating positive values from a log-normal distribution, with added zero inflation.
#' The probability of a g-score being zero is controlled by `prob_zero`, while positive values are generated as log-normal.
#'
#' P(G=0) = p, P(G>0) = 1-p;
#' log(G) | G > 0 ~ N(mu, sigma^2)
#'
#' @param n A scalar. Number of patients in the arm of interest.
#' @param mu A scalar. Mean value of the normal distribution for generating the log of positive g-scores.
#' @param sigma A scalar. Standard deviation of the normal distribution for generating the log of positive g-scores.
#' @param prob_zero A scalar. Probability of a g-score being zero.
#'
#' @return A vector. Simulated g-scores.
#' @export
#'
#' @examples
#' simulate_gscore(n = 100, mu = 1, sigma = 0.5, prob_zero = 0.2)
simulate_gscore <- function(n, mu, sigma, prob_zero) {
  is_zero <- stats::rbinom(n, 1, prob_zero)
  non_zero_data <- stats::rnorm(sum(!is_zero), mean = mu, sd = sigma)
  data <- rep(0, n)
  data[!is_zero] <- exp(non_zero_data)
  return(data)
}


#' Calculate True Median of g-scores
#'
#' This function calculates the true median of g-scores generated by a log-normal distribution, accounting for zero inflation.
#' When p = 0, i.e., no zero g-scores, the true median is just e^mu.
#'
#' @param p A scalar. Probability of a g-score being zero.
#' @param mu A scalar. Mean value of the normal distribution for generating log of positive g-scores.
#' @param sigma A scalar. Standard deviation of the normal distribution for generating log of positive g-scores.
#'
#' @return A scalar. True median of the g-scores.
#' @export
#'
#' @examples
#' get_true_gscore_median(p = 0.3, mu = 1, sigma = 0.5)
get_true_gscore_median <- function(p, mu, sigma) {
  exp(mu + stats::qnorm(max(0.5 - p, 0) / (1 - p)) * sigma)
}


#' Variance Estimator for g-score Median Estimate
#'
#' This function calculates the variance estimator for the median estimate of g-scores, based on the method proposed by Price & Bonett (2001).
#'
#' @param x A vector of g-scores.
#'
#' @return A scalar. Variance estimator for the g-score median.
#' @export
#'
#' @examples
#' g_scores <- simulate_gscore(n = 100, mu = 1, sigma = 0.5, prob_zero = 0.2)
#' sd_gscore_median(g_scores)
sd_gscore_median <- function(x) {
  n <- length(x)
  xx <- sort(x)
  cc <- round((n + 1) / 2 - 1.96 * sqrt(n / 4))
  cc1 <- cc
  cc1[cc1 == 0] <- 1
  alpha <- sum(choose(n, 0:(cc1 - 1)) * 0.5^(n - 1))
  z_alpha <- stats::qnorm(1 - alpha / 2)
  se <- (xx[n - cc1 + 1] - xx[cc1]) / (2 / sqrt(n) + 2 * z_alpha)

  return(se)
}


#' Evaluate g-score Median Ratio Estimation
#'
#' This function evaluates the reliability of the normal approximation for g-score median estimates.
#' For each simulation repetition, it computes the log-median ratio and evaluates metrics such as bias, standard error, and coverage probability.
#'
#' @param sim_data A data frame. Data simulated by the `data_gen_gscore()` function.
#'
#' @return A data frame containing evaluation metrics for the g-score median ratio:
#'   - bias_avg: Average bias of the log-median ratio estimates.
#'   - bias_avg_median_ratio1: Average bias of the median ratio, obtained by exponentiating the average of log median ratio estimates and subtracting the true median ratio
#'   - bias_avg_median_ratio2: Average bias of the median ratio, obtained by exponentiating the log median estimates for both arms to obtain the median ratio estimates for each repetition and taking the average bias over all repetitions of simulation
#'   - sd_avg: Average standard error of the log-median ratio estimates.
#'   - sd_empirical: Empirical standard deviation of the log-median ratio estimates.
#'   - cp: Coverage probability for the 95% confidence interval.
#' @export
#'
#' @examples
#' # Generating sim_data by function data_gen_gscore()
#' n_list <- c(treatment = 100, control = 100)
#' prob_list <- c(treatment = 0.2, control = 0.3)
#' mu_list <- c(treatment = 0.5, control = 0.6)
#' sigma_list <- c(treatment = 0.1, control = 0.2)
#' arm_names <- c(treatment = "treatment", control = "control")
#' sim_data <- data_gen_gscore(n_arms = 2, nsim = 10, n_list = n_list,
#'                             prob_list = prob_list, mu_list = mu_list,
#'                             sigma_list = sigma_list, arm_names = arm_names)
#'
#' eval_gscore_approx_dist(sim_data = sim_data)
#'
#' @import dplyr
#' @import tidyr
#' @importFrom rlang .data
eval_gscore_approx_dist <- function(sim_data){

  # True median ratio: delta = theta_t / theta_c
  delta = sim_data$true_value$compare_true
  # Parameter of interest: log(delta) = log(theta_t/theta_c) = mu_t - mu_c
  log_delta = log(delta)

  # Point estimate of log_delta for each run: log_delta_hat = log(theta_t_hat) - log(theta_c_hat) = mu_t_hat - mu_c_hat
  median_est_wide <- sim_data$median_est %>%
    dplyr::filter(.data$arm %in% c("treatment", "control")) %>%
    pivot_wider(
      names_from = .data$arm,
      values_from = c(.data$median_unadjusted, .data$median_adjusted, .data$median_sd),
      names_sep = "."
    )
  log_delta_hat = log(median_est_wide$median_adjusted.treatment) - log(median_est_wide$median_adjusted.control)

  # Average Bias of log_delta_hat
  bias_avg <- mean(log_delta_hat - log_delta)

  # Average Bias of estimated median ratio
  bias_avg_median_ratio1 <- exp(mean(log_delta_hat)) - delta
  median_ratio_hat = median_est_wide$median_adjusted.treatment / median_est_wide$median_adjusted.control
  bias_avg_median_ratio2 = mean(median_ratio_hat - delta)

  # Average SD (i.e., SE) of log_delta_hat
  # SD = sqrt(var(mu_t_hat) + var(mu_c_hat))
  # var(mu_hat) = V_ZH / theta_hat^2
  var_mu_hat_t = (median_est_wide$median_sd.treatment)^2 / ((median_est_wide$median_adjusted.treatment)^2)
  var_mu_hat_c = (median_est_wide$median_sd.control)^2 / ((median_est_wide$median_adjusted.control)^2)
  sds <- sqrt(var_mu_hat_t + var_mu_hat_c)
  sd_avg = mean(sds)

  # Empirical SD of log_delta_hat
  sd_empirical = stats::sd(log_delta_hat)

  # Coverage probability 95%
  ci = data.frame(cil = log_delta_hat + stats::qnorm(0.025) * sds,
                  ciu = log_delta_hat + stats::qnorm(0.975) * sds)
  ci$coverage = ifelse(ci$cil < log_delta & ci$ciu > log_delta, 1, 0)
  cp = mean(ci$coverage)

  metrics <- data.frame(log_delta = log_delta,
                        bias_avg = bias_avg,
                        bias_avg_median_ratio1 = bias_avg_median_ratio1,
                        bias_avg_median_ratio2 = bias_avg_median_ratio2,
                        sd_avg = sd_avg,
                        sd_empirical = sd_empirical,
                        cp = cp)

  return(metrics)
}


