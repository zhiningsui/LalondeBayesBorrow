#' Generating g-scores
#'
#' This function generates g-scores
#'
#' @param n_arms A scalar. Number of arms to be generated
#' @param nsim A scalar. Number of repetitions of simulation
#' @param n_list A list. Each object represents the number of patients in each arm
#' @param prob_list A list. Each object represents the probability of a g-score being zero in each arm
#' @param mu_list A list. Each object represents the mean of the normal distribution for generating log of positive g-score in each arm
#' @param sigma_list A list. Each object represents the standard deviation of the normal distribution for generating log of positive g-score in each arm
#' @param arm_names A list. Each object represents the name of each arm
#'
#' @return A list of dataframes:
#'  \itemize{
#'  \item data: Individual level g-scores for all arms and all repetitions of simulation
#'  \item true_value: True medians for all arms and the true median ratio
#'  \item median_est: Adjusted median estimates and variance estimators for the median estimates
#'  }
#' @export
#'
#' @examples
#'
data_gen_gscore <- function(n_arms = 2, nsim = 10, n_list = NULL, prob_list = NULL, mu_list = NULL, sigma_list = NULL, arm_names = NULL) {
  true_value <- data.frame(arm = arm_names,
                           true_value = mapply(get_true_gscore_median,
                                               prob_list, mu_list, sigma_list)) %>%
    pivot_wider(names_from = arm, values_from = true_value, names_glue = "{arm}.true_value")

  if (sum(arm_names %in% c("treatment", "control")) >= 2) {
    true_value <- true_value %>%
      mutate(compare_true = !!sym(paste0(arm_names[arm_names == "treatment"], ".true_value")) / !!sym(paste0(arm_names[arm_names == "control"], ".true_value")))
  } else {
    true_value <- true_value %>%
      mutate(compare_true = NA)
  }

  cl <- makeCluster(detectCores() - 1)

  required_vars <- c("n_list", "mu_list", "sigma_list", "prob_list", "arm_names",
                     "simulate_gscore", "sd_gscore_median")

  clusterExport(cl, required_vars, envir = environment())
  clusterEvalQ(cl, {
    library(dplyr)
    library(tidyr)
    library(data.table)
  })

  results <- parLapply(cl, 1:nsim, function(nrep) {
    # set.seed(20240702 + 10000 * nrep)
    data_temp <- data.table(
      nsim = rep(nrep, each = sum(n_list)),
      id = unlist(lapply(n_list, seq)),
      arm = unlist(as.list(mapply(rep, arm_names, n_list))),
      g_score = unlist(as.list(mapply(simulate_gscore, n_list, mu_list, sigma_list, prob_list)))
    )

    data_temp$arm <- factor(data_temp$arm, levels = arm_names)
    rownames(data_temp) <- NULL

    med_temp <- data_temp %>%
      group_by(arm) %>%
      summarize(
        median_unadjusted = median(g_score),
        median_sd = sd_gscore_median(g_score)
      ) %>%
      mutate(
        n = n_list,
        median_adjusted = ifelse(median_unadjusted == 0, min(data_temp$g_score[data_temp$g_score > 0]) / sqrt(n), median_unadjusted),
        nsim = nrep
      )

    list(data = data_temp, median = med_temp)
  })

  stopCluster(cl)

  data <- rbindlist(lapply(results, "[[", "data"))
  g_median <- rbindlist(lapply(results, "[[", "median"))
  setcolorder(g_median, c("nsim", "arm", "n", "median_unadjusted", "median_adjusted", "median_sd"))
  return(list(data = data, true_value = true_value, median_est = g_median))
}



#' Title
#'
#' @param n_arms A scalar. Number of arms to be generated
#' @param nsim A scalar. Number of repetitions of simulation
#' @param n_list A list. Each object represents the number of patients in each arm
#' @param prob_list A list. Each object represents the probability of response in each arm
#' @param arm_names A list. Each object represents the name of each arm
#'
#' @return A list of dataframes:
#'  \itemize{
#'  \item data: Individual level binary endpoint outcomes (0/1) for all arms and all repetitions of simulation
#'  \item true_value: True rate of response for all arms and the true rate difference
#'  \item freq: Frequencies of responses with aach row representing the number of responses and the total number of patients in all arms in one repetition of simulation
#'  }

#' @export
#'
#' @examples
data_gen_binary <- function(n_arms = 2, nsim = 10, n_list = NULL, prob_list = NULL, arm_names = NULL) {
  rate_true <- data.frame(arm = arm_names,
                           rate_true = unlist(prob_list)) %>%
      pivot_wider(names_from = arm, values_from = rate_true, names_glue = "{arm}.rate_true")

  if (sum(arm_names %in% c("treatment", "control")) >= 2) {
    rate_true <- rate_true %>%
      mutate(compare_true = !!sym(paste0(arm_names[arm_names == "treatment"], ".rate_true")) - !!sym(paste0(arm_names[arm_names == "control"], ".rate_true")))
  } else {
    rate_true <- rate_true %>%
      mutate(compare_true = NA)
  }

  cl <- makeCluster(detectCores() - 1)
  clusterExport(cl, list("n_list", "prob_list", "arm_names", "n_arms"), envir = environment())
  clusterEvalQ(cl, {
    library(dplyr)
    library(tidyr)
    library(data.table)
  })

  results <- parLapply(cl, 1:nsim, function(nrep) {
   data_temp <- data.table(
      nsim = rep(nrep, each = sum(n_list)),
      id = unlist(lapply(n_list, seq)),
      arm = unlist(as.list(mapply(rep, arm_names, n_list))),
      resp = unlist(as.list(mapply(rbinom, n_list, as.list(rep(1, n_arms)), prob_list)))
    )
    data_temp[, arm := factor(arm, levels = arm_names)]
    data_temp
  })

  stopCluster(cl)

  data <- rbindlist(results)
  freq <- freq_binary(data, n_list)

  return(list(data = data, true_value = rate_true, freq = freq))

}


