#' Generating g-score
#'
#' This function generates g-scores by simulating positive values from a lognormal distribution with added zero inflation.
#' P(G=0) = p, P(G>0) = p;
#' log(G)|G>0 ~ N(mu, sigma^2)
#'
#' @param n A scalar. Number of patients in the arm of interest
#' @param mu A scalar. Mean value of the normal distribution for generating log of positive g-score
#' @param sigma A scalar. Standard deviation of the normal distribution for generating log of positive g-score
#' @param prob_zero A scalar. Probability of a g-score being zero
#'
#' @return A vector of simulated g-scores
#' @export
#'
#' @examples
simulate_gscore <- function(n, mu, sigma, prob_zero) {
  is_zero <- rbinom(n, 1, prob_zero)
  non_zero_data <- rnorm(sum(!is_zero), mean = mu, sd = sigma)
  data <- rep(0, n)
  data[!is_zero] <- exp(non_zero_data)
  return(data)
}


#' Obtaining true median of g-scores
#'
#' This function calculates the true median of g-score whose positive values are generated by a lognormal distribution.
#' The true median is calculated using the data generating parameters of g-scores.
#'
#' @param p A scalar. Probability of a g-score being zero
#' @param mu A scalar. Mean value of the normal distribution for generating log of positive g-score
#' @param sigma A scalar. Standard deviation of the normal distribution for generating log of positive g-score
#'
#' @return A scalar true median for the simulated g-scores
#' @export
#'
#' @examples
get_true_gscore_median <- function(p, mu, sigma) {
  exp(mu + qnorm(max(0.5 - p, 0) / (1 - p)) * sigma)
}



#' Obtaining the variance estimator of g-score median estimate
#'
#' This function calculates the variance estimator for g-score median estimate
#' proposed by Price & Bonett (2001).
#'
#' @param x A vector of g-scores
#'
#' @return A scalar variance estimator for g-score median estimate
#' @export
#'
#' @examples
sd_gscore_median <- function(x) {
  n <- length(x)
  xx <- sort(x)
  cc <- round((n + 1) / 2 - 1.96 * sqrt(n / 4))
  cc1 <- cc
  cc1[cc1 == 0] <- 1
  alpha <- sum(choose(n, 0:(cc1 - 1)) * 0.5^(n - 1))
  z_alpha <- qnorm(1 - alpha / 2)
  se <- (xx[n - cc1 + 1] - xx[cc1]) / (2 / sqrt(n) + 2 * z_alpha)

  return(se)
}


#' Evaluation of g-score median ratio estimation
#'
#' This function evaluates the reliability of the normal approximation for g-score median estimates.
#' For each repetition, obtain the point estimate of log median ratio, log_delta_hat = log(theta_t_hat) - log(theta_c_hat),
#' and the standard error SE = sqrt(V_{PBt}/theta_t_hat^2 + V_{PBc}/theta_c_hat^2).
#'
#'
#' @param sim_data A dataframe. Data simulated by function data_gen().
#'
#' @return A dataframe containing the true median ratio and the evaluating metrics
#'  \itemize{
#'  \item bias_avg: Average bias of the log median ratio estimates over all repetitions of simulation
#'  \item bias_avg_median_ratio1: Average bias of the median ratio, obtained by exponentiating the average of log median ratio estimates and subtracting the true median ratio
#'  \item bias_avg_median_ratio2: Average bias of the median ratio, obtained by exponentiating the log median estimates for both arms to obtain the median ratio estimates for each repetition and taking the average bias over all repetitions of simulation
#'  \item sd_avg: Average standard error of log median ratio estimates over all repetitions of simulation
#'  \item sd_empirical: Empirical standard deviation of the log median ratio estimates across all repetitions of simulation
#'  \item cp: Nominal coverage probability of 95% confidence interval
#'  }
#' @export
#'
#' @examples
eval_gscore_approx_dist <- function(sim_data){

  # True median ratio: delta = theta_t / theta_c
  delta = sim_data$true_value$compare_true
  # Parameter of interest: log(delta) = log(theta_t/theta_c) = mu_t - mu_c
  log_delta = log(delta)

  # Point estimate of log_delta for each run: log_delta_hat = log(theta_t_hat) - log(theta_c_hat)
  median_est_wide <- sim_data$median_est %>%
    filter(arm %in% c("treatment", "control")) %>%
    pivot_wider(
      names_from = arm,
      values_from = c(median_unadjusted, median_adjusted, median_sd),
      names_sep = "."
    )
  log_delta_hat = log(median_est_wide$median_adjusted.treatment) - log(median_est_wide$median_adjusted.control)

  # Average Bias of log_delta_hat
  bias_avg <- mean(log_delta_hat - log_delta)

  # Average Bias of estimated median ratio
  bias_avg_median_ratio1 <- exp(mean(log_delta_hat)) - delta
  median_ratio_hat = median_est_wide$median_adjusted.treatment / median_est_wide$median_adjusted.control
  bias_avg_median_ratio2 = mean(median_ratio_hat - delta)

  # Average SD (i.e., SE) of log_delta_hat
  # SD = sqrt(var(mu_t_hat) + var(mu_c_hat))
  # var(mu_hat) = V_ZH / theta_hat^2
  var_mu_hat_t = (median_est_wide$median_sd.treatment)^2 / ((median_est_wide$median_adjusted.treatment)^2)
  var_mu_hat_c = (median_est_wide$median_sd.control)^2 / ((median_est_wide$median_adjusted.control)^2)
  sds <- sqrt(var_mu_hat_t + var_mu_hat_c)
  sd_avg = mean(sds)

  # Empirical SD of log_delta_hat
  sd_empirical = sd(log_delta_hat)

  # Coverage probability 95%
  ci = data.frame(cil = log_delta_hat + qnorm(0.025) * sds,
                  ciu = log_delta_hat + qnorm(0.975) * sds)
  ci$coverage = ifelse(ci$cil < log_delta & ci$ciu > log_delta, 1, 0)
  cp = mean(ci$coverage)

  metrics <- data.frame(log_delta = log_delta,
                        bias_avg = bias_avg,
                        bias_avg_median_ratio1 = bias_avg_median_ratio1,
                        bias_avg_median_ratio2 = bias_avg_median_ratio2,
                        sd_avg = sd_avg,
                        sd_empirical = sd_empirical,
                        cp = cp)

  return(metrics)
}


