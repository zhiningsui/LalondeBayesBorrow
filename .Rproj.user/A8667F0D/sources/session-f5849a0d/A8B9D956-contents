#' Calculate Posterior Distribution Metrics
#'
#' This function calculates various evaluation metrics for the posterior distribution, including the average bias, standard error, empirical standard deviation, and nominal coverage probability.
#' For the "g-score" endpoint, it calculates the log-median ratio, and for the "OR" endpoint, it calculates the rate difference.
#'
#' @param endpoint A string. Specifies the type of endpoint ("g-score" or "OR").
#' @param true_value A scalar. The true median ratio for the "g-score" endpoint or the true rate difference for the "OR" endpoint.
#' @param post_est_ci A dataframe. Contains posterior inference obtained from `bayesian_lalonde_decision()`, including posterior estimates, standard errors, and 95% credible intervals for each simulation repetition.
#'
#' @return A dataframe containing the evaluation metrics for the posterior distribution, including:
#'   - `bias_avg`: The average bias of the estimate.
#'   - `sd_avg`: The average standard error of the estimate.
#'   - `sd_empirical`: The empirical standard deviation of the estimate.
#'   - `cp`: The nominal coverage probability (95%).
#'   - Additional metrics specific to the "g-score" endpoint. More details can be found in `eval_gscore_approx_dist()`.
#' @export
#'
#' @examples
#' calc_post_dist_metrics("g-score", true_value = 1.2, post_est_ci = posterior_inference_results)
#'
calc_post_dist_metrics <- function(endpoint, true_value, post_est_ci) {
  if (endpoint == "g-score") {
    # Parameter of interest: log_delta = log(theta_t/theta_c)
    log_delta <- log(true_value)

    # Point estimate for each run: log_delta_hat = log(theta_t_hat) - log(theta_c_hat)
    log_delta_hat <- log(post_est_ci$est1) - log(post_est_ci$est2)

    # Average Bias of log_delta_hat
    bias_avg <- mean(log_delta_hat - log_delta)

    # Average Bias of estimated median ratio
    bias_avg_median_ratio1 <- exp(mean(log_delta_hat)) - true_value
    median_ratio_hat <- post_est_ci$est_compare
    bias_avg_median_ratio2 <- mean(median_ratio_hat - true_value)

    # Average SD (i.e., SE) of log_delta_hat
    sds <- post_est_ci$sd_compare
    sd_avg <- mean(sds)

    # Empirical SD of log_delta_hat
    sd_empirical <- sd(log_delta_hat)

    # Coverage probability 95%
    ci <- data.frame(cil = log(post_est_ci$compare_ci_l),
                     ciu = log(post_est_ci$compare_ci_u))
    ci$coverage <- ifelse(ci$cil < log_delta & ci$ciu > log_delta, 1, 0)
    cp <- mean(ci$coverage)

    metrics <- data.frame(log_delta = log_delta,
                          bias_avg = bias_avg,
                          bias_avg_median_ratio1 = bias_avg_median_ratio1,
                          bias_avg_median_ratio2 = bias_avg_median_ratio2,
                          sd_avg = sd_avg,
                          sd_empirical = sd_empirical,
                          cp = cp)

  } else if (endpoint == "OR") {
    # Parameter of interest: delta = rate_t - rate_c
    delta <- true_value

    # Point estimate for each run: delta_hat = rate_t_hat - rate_c_hat
    delta_hat <- post_est_ci$est_compare

    # Average Bias of estimated rate difference
    bias_avg_rate_diff <- mean(delta_hat - delta)

    # Average SD (i.e., SE) of delta_hat
    sds <- post_est_ci$sd_compare
    sd_avg <- mean(sds)

    # Empirical SD of delta_hat
    sd_empirical <- sd(delta_hat)

    # Coverage probability 95%
    ci <- data.frame(cil = post_est_ci$compare_ci_l,
                     ciu = post_est_ci$compare_ci_u)
    ci$coverage <- ifelse(ci$cil < delta & ci$ciu > delta, 1, 0)
    cp <- mean(ci$coverage)

    metrics <- data.frame(delta = delta,
                          bias_avg_rate_diff = bias_avg_rate_diff,
                          sd_avg = sd_avg,
                          sd_empirical = sd_empirical,
                          cp = cp)
  }

  return(metrics)
}



#' Calculate Response Frequencies for Binary Endpoints
#'
#' This function calculates the frequency of binary endpoint responses (0/1) for all arms across multiple simulation repetitions.
#' It groups data by arm and simulation repetition to count the number of responses and the total number of patients in each arm.
#'
#' @param data A dataframe. Contains individual-level binary outcomes (0/1) for all arms and repetitions of the simulation.
#' @param n_list A list. Each element represents the number of patients in each arm.
#'
#' @return A dataframe with each row representing the number of responses and the total number of patients in each arm for each simulation repetition. The dataframe includes columns for:
#'   - `nsim`: Simulation repetition number.
#'   - `arm.n`: Total number of patients in each arm.
#'   - `arm.count`: Total number of responses in each arm.
#' @export
#'
#' @examples
#' freq_binary(data = binary_data, n_list = list(100, 100))
#'
freq_binary <- function(data, n_list) {
  freq <- data %>%
    group_by(nsim, arm, resp) %>%
    summarise(count = n(), .groups = 'drop') %>%
    ungroup() %>%
    complete(nsim, arm, resp, fill = list(count = 0)) %>%
    mutate(n = case_when(TRUE ~ n_list[as.integer(factor(arm, levels = levels(data$arm)))])) %>%
    filter(resp == 1) %>%
    group_by(nsim, arm) %>%
    summarise(n = unique(n), count = sum(count)) %>%
    pivot_wider(names_from = arm, values_from = c(n, count),names_glue = "{arm}.{.value}") %>%
    select(nsim, ends_with(".n"), ends_with(".count"))

  return(freq = freq)
}


#' Retrieve All Functions from an Environment
#'
#' This function returns the names of all functions within a specified environment.
#'
#' @param env The environment to search for functions. Default is the current environment.
#'
#' @return A character vector of function names found in the specified environment.
#'
#' @export
#'
#' @examples
#' # Get all functions in the global environment
#' get_all_functions(env = globalenv())
#'
get_all_functions <- function(env = environment()) {
  all_objects <- ls(env)
  functions <- sapply(all_objects, function(obj_name) is.function(get(obj_name, envir = env)))
  return(names(functions)[functions])
}


#' Convert to RBesT Mixture Distribution
#'
#' This function generates a mixture distribution in the format required by the R package `RBesT` from a given set of parameters.
#' It supports both continuous and binary endpoints, constructing either normal or beta mixture distributions depending on the endpoint type.
#'
#' @param post A data frame. Contains parameters for the mixture distribution, including the weight (`w`) of each component, and the distribution parameters for each component.
#'   - For continuous endpoints, the parameters include `w`, `mu1`, `sigma1`, `mu2`, and `sigma2`.
#'   - For binary endpoints, the parameters include `w`, `a1`, `b1`, `a2`, and `b2`.
#' @param endpoint A string. Specifies the type of endpoint, either "continuous" (for normal distributions) or "binary" (for beta distributions).
#'
#' @return An RBesT mixture distribution object. The object will be of class `mixnorm` for continuous endpoints or `mixbeta` for binary endpoints.
#' @export
#'
#' @examples
#' # Example for continuous endpoint
#' post <- data.frame(w = 0.5, mu1 = 0, sigma1 = 1, mu2 = 0.5, sigma2 = 1)
#' mix_dist <- convert_RBesT_mix(post, "continuous")
#'
#' # Example for binary endpoint
#' post <- data.frame(w = 0.5, a1 = 1, b1 = 1, a2 = 2, b2 = 2)
#' mix_dist <- convert_RBesT_mix(post, "binary")
#'
convert_RBesT_mix <- function(post, endpoint){
  names(post) <- sapply(strsplit(gsub("_post", "", names(post)), "\\."), "[[", 2)
  if (endpoint == "continuous") {
    if(!is.data.frame(post)) post <- as.data.frame(t(post))
    # Define the normal mixture distributions using RBesT
    if (post$w == 0) {
      post = mixnorm(c(1-unname(post$w), unname(post$mu2), unname(post$sigma2)))
    } else if (post$w == 1){
      post = mixnorm(c(unname(post$w), unname(post$mu1), unname(post$sigma1)))
    }
    else {
      post = mixnorm(c(unname(post$w), unname(post$mu1), unname(post$sigma1)),
                     c(1-unname(post$w), unname(post$mu2), unname(post$sigma2)))
    }
  } else if (endpoint == "binary") {
    # Define the beta mixture distributions using RBesT
    if (post$w == 0) {
      post = mixbeta(c(1-unname(post$w), unname(post$a2), unname(post$b2)))
    } else if (post$w == 1){
      post = mixbeta(c(unname(post$w), unname(post$a1), unname(post$b1)))
    }else {
      post = mixbeta(c(unname(post$w), unname(post$a1), unname(post$b1)),
                     c(1-unname(post$w), unname(post$a2), unname(post$b2)))
    }
  }
  return(post)
}

#' Create Data Generation Parameters
#'
#' This function processes and validates a set of parameters for generating data
#' related to treatment and control groups, along with their historical counterparts.
#' It checks for missing values and replaces them with `NA` while issuing warnings.
#' The function supports different endpoints, and the interpretation of the `prob` parameter
#' varies depending on the specified endpoint:
#'   - For the "g-score" endpoint, `prob` refers to the probability of zero g-scores.
#'   - For the "OR" endpoint, `prob` may represent the probability of an event occurring.
#'
#' @param params A list containing the parameters for data generation.
#'   The list should include:
#'   - `trt_n` (numeric): Sample size for the treatment group.
#'   - `ctrl_n` (numeric): Sample size for the control group. If not provided, it will be set to match `trt_n`.
#'   - `trt_prob` (numeric): Probability for the treatment group, interpretation based on the `endpoint`.
#'   - `ctrl_prob` (numeric): Probability for the control group, interpretation based on the `endpoint`.
#'   - `trt_mu` (numeric): Mean value for the treatment group (for non-zero values in g-scores or other continuous endpoints).
#'   - `ctrl_mu` (numeric): Mean value for the control group.
#'   - `trt_sigma` (numeric): Standard deviation for the treatment group (for non-zero values in g-scores or other continuous endpoints).
#'   - `ctrl_sigma` (numeric): Standard deviation for the control group.
#'   - Additional parameters for historical data (e.g., `trt_h_n`, `ctrl_h_prob`) may also be included.
#' @param endpoint A string specifying the endpoint type. The meaning of the `prob` parameter
#'   depends on this value:
#'   - "g-score": `prob` refers to the probability of zero g-scores.
#'   - "OR": `prob` refers to the probability of an event occurring.
#'
#' @return A nested list containing the processed parameters for each group:
#'   - `treatment`: Parameters for the treatment group.
#'   - `control`: Parameters for the control group.
#'   - `treatment_h`: Parameters for the historical treatment group.
#'   - `control_h`: Parameters for the historical control group.
#'
#' Missing values are replaced with `NA` and a warning is issued for each missing parameter.
#'
#' @export
#'
#' @examples
#' # Example usage:
#' params <- list(trt_n = 100, trt_prob = 0.6, trt_mu = 1.5, trt_sigma = 0.3,
#'                ctrl_n = 100, ctrl_prob = 0.4, ctrl_mu = 1.2, ctrl_sigma = 0.2)
#' create_data_gen_params(params, "g-score")
#'
create_data_gen_params <- function(params, endpoint) {
  check_param <- function(param, param_name) {
    if (!is.null(param)) {
      return(param)
    } else {
      warning(paste("Warning: Parameter", param_name, "is missing. Replacing with NA."))
      return(NA)
    }
  }
  safe_log <- function(param, param_name) {
    if (!is.null(param)) {
      return(log(param))
    } else {
      warning(paste("Warning: Parameter", param_name, "is missing. Replacing with NA."))
      return(NA)
    }
  }
  param_list <- list(
    treatment = list(
      n = check_param(params$trt_n, "trt_n"),
      prob = check_param(params$trt_prob, "trt_prob"),
      mu = safe_log(params$trt_mu, "trt_mu"),
      sigma = check_param(params$trt_sigma, "trt_sigma"),
      name = "treatment"
    ),
    control = list(
      n = check_param(params$ctrl_n, "ctrl_n"),
      prob = check_param(params$ctrl_prob, "ctrl_prob"),
      mu = safe_log(params$ctrl_mu, "ctrl_mu"),
      sigma = check_param(params$ctrl_sigma, "ctrl_sigma"),
      name = "control"
    ),
    treatment_h = list(
      n = check_param(params$trt_h_n, "trt_h_n"),
      prob = check_param(params$trt_h_prob, "trt_h_prob"),
      mu = safe_log(params$trt_h_mu, "trt_h_mu"),
      sigma = check_param(params$trt_h_sigma, "trt_h_sigma"),
      name = "treatment_h"
    ),
    control_h = list(
      n = check_param(params$ctrl_h_n, "ctrl_h_n"),
      prob = check_param(params$ctrl_h_prob, "ctrl_h_prob"),
      mu = safe_log(params$ctrl_h_mu, "ctrl_h_mu"),
      sigma = check_param(params$ctrl_h_sigma, "ctrl_h_sigma"),
      name = "control_h"
    )
  )
  # Filter out entries with missing n or prob parameters
  if(endpoint == "g-score"){
    param_list_filtered <- Filter(function(x) !any(sapply(x, is.na)), param_list)
  } else if (endpoint == "OR"){
    param_list_filtered <- Filter(function(x) !any(sapply(x[c("n", "prob")], is.na)), param_list)
  }

  return(param_list_filtered)
}



