#' Generate g-scores
#'
#' This function generates g-scores for multiple arms of a study across multiple simulation repetitions.
#' It simulates individual-level g-scores for each arm based on specified probabilities, means,
#' and standard deviations for the g-score distributions. The function outputs true median values
#' and adjusted median estimates along with their variance.
#'
#' @param n_arms A scalar. Number of arms to be generated.
#' @param nsim A scalar. Number of repetitions for the simulation.
#' @param n_list A list. Each element represents the number of patients in each arm.
#' @param prob_list A list. Each element represents the probability of a g-score being zero in each arm.
#' @param mu_list A list. Each element represents the mean of the normal distribution for generating the log of positive g-scores in each arm.
#' @param sigma_list A list. Each element represents the standard deviation of the normal distribution for generating the log of positive g-scores in each arm.
#' @param arm_names A list. Each element represents the name of each arm.
#'
#' @return A list of data frames:
#' \itemize{
#'   \item \code{data}: A data frame containing individual-level g-scores for all arms and all repetitions of the simulation.
#'   \item \code{true_value}: A data frame with the true medians for all arms and the true median ratio for treatment vs. control (if both are present).
#'   \item \code{median_est}: A data frame with adjusted median estimates for each arm, along with the variance estimators for the median estimates.
#' }
#' @export
#'
#' @examples
#' # Example of generating g-scores for a study with 2 arms, 100 patients in each arm,
#' # and 10 simulation repetitions:
#' n_list <- list(100, 100)
#' prob_list <- list(0.2, 0.3)
#' mu_list <- list(0.5, 0.6)
#' sigma_list <- list(0.1, 0.2)
#' arm_names <- list("treatment", "control")
#' result <- data_gen_gscore(n_arms = 2, nsim = 10, n_list = n_list, prob_list = prob_list,
#'                           mu_list = mu_list, sigma_list = sigma_list, arm_names = arm_names)
#'
#' @import dplyr
#' @import tidyr
#' @import parallel
#' @import data.table
data_gen_gscore <- function(n_arms = 2, nsim = 10, n_list = NULL, prob_list = NULL, mu_list = NULL, sigma_list = NULL, arm_names = NULL) {
  true_value <- data.frame(arm = arm_names,
                           true_value = mapply(get_true_gscore_median,
                                               prob_list, mu_list, sigma_list)) %>%
    pivot_wider(names_from = arm, values_from = true_value, names_glue = "{arm}.true_value")

  if (sum(arm_names %in% c("treatment", "control")) >= 2) {
    true_value <- true_value %>%
      mutate(compare_true = !!sym(paste0(arm_names[arm_names == "treatment"], ".true_value")) / !!sym(paste0(arm_names[arm_names == "control"], ".true_value")))
  } else {
    true_value <- true_value %>%
      mutate(compare_true = NA)
  }

  cl <- makeCluster(detectCores() - 1)

  required_vars <- c("n_list", "mu_list", "sigma_list", "prob_list", "arm_names",
                     "simulate_gscore", "sd_gscore_median")

  clusterExport(cl, required_vars, envir = environment())
  clusterEvalQ(cl, {
    library(dplyr)
    library(tidyr)
    library(data.table)
  })

  results <- parLapply(cl, 1:nsim, function(nrep) {
    data_temp <- data.table(
      nsim = rep(nrep, each = sum(n_list)),
      id = unlist(lapply(n_list, seq)),
      arm = unlist(as.list(mapply(rep, arm_names, n_list))),
      g_score = unlist(as.list(mapply(simulate_gscore, n_list, mu_list, sigma_list, prob_list)))
    )

    data_temp$arm <- factor(data_temp$arm, levels = arm_names)
    rownames(data_temp) <- NULL

    med_temp <- data_temp %>%
      group_by(arm) %>%
      summarize(
        median_unadjusted = median(g_score),
        median_sd = sd_gscore_median(g_score)
      ) %>%
      mutate(
        n = n_list,
        median_adjusted = ifelse(median_unadjusted == 0, min(data_temp$g_score[data_temp$g_score > 0]) / sqrt(n), median_unadjusted),
        nsim = nrep
      )

    list(data = data_temp, median = med_temp)
  })

  stopCluster(cl)

  data <- rbindlist(lapply(results, "[[", "data"))
  g_median <- rbindlist(lapply(results, "[[", "median"))
  setcolorder(g_median, c("nsim", "arm", "n", "median_unadjusted", "median_adjusted", "median_sd"))
  return(list(data = data, true_value = true_value, median_est = g_median))
}



#' Generate Binary Response Data
#'
#' This function simulates binary endpoint data (0/1) for multiple study arms across several simulation repetitions.
#' Each arm's data is generated based on the specified probabilities of response, and the function returns
#' individual-level data as well as summary statistics for the true response rates and response frequencies.
#'
#' @param n_arms A scalar. The number of arms to be generated in the simulation.
#' @param nsim A scalar. The number of repetitions of the simulation to be performed.
#' @param n_list A list. Each element represents the number of patients in each arm.
#' @param prob_list A list. Each element represents the probability of response (binary outcome = 1) for each arm.
#' @param arm_names A list. Each element represents the name of the corresponding arm.
#'
#' @return A list of data frames:
#' \itemize{
#'   \item \code{data}: A data frame containing individual-level binary outcomes (0/1) for all arms and all repetitions of the simulation.
#'   \item \code{true_value}: A data frame of true response rates for each arm, along with the difference in response rates between the treatment and control arms (if both are present).
#'   \item \code{freq}: A data frame of response frequencies, where each row represents the number of responses and the total number of patients in each arm for each simulation repetition.
#' }
#' @export
#'
#' @examples
#' # Example of generating binary response data for 2 arms, 100 patients per arm,
#' # and 10 simulation repetitions:
#' n_list <- list(100, 100)
#' prob_list <- list(0.4, 0.5)
#' arm_names <- list("treatment", "control")
#' result <- data_gen_binary(n_arms = 2, nsim = 10, n_list = n_list, prob_list = prob_list, arm_names = arm_names)
#'
#' @import dplyr
#' @import tidyr
#' @import parallel
#' @import data.table
data_gen_binary <- function(n_arms = 2, nsim = 10, n_list = NULL, prob_list = NULL, arm_names = NULL) {
  rate_true <- data.frame(arm = arm_names,
                           rate_true = unlist(prob_list)) %>%
      pivot_wider(names_from = arm, values_from = rate_true, names_glue = "{arm}.rate_true")

  if (sum(arm_names %in% c("treatment", "control")) >= 2) {
    rate_true <- rate_true %>%
      mutate(compare_true = !!sym(paste0(arm_names[arm_names == "treatment"], ".rate_true")) - !!sym(paste0(arm_names[arm_names == "control"], ".rate_true")))
  } else {
    rate_true <- rate_true %>%
      mutate(compare_true = NA)
  }

  cl <- makeCluster(detectCores() - 1)
  clusterExport(cl, list("n_list", "prob_list", "arm_names", "n_arms"), envir = environment())
  clusterEvalQ(cl, {
    library(dplyr)
    library(tidyr)
    library(data.table)
  })

  results <- parLapply(cl, 1:nsim, function(nrep) {
   data_temp <- data.table(
      nsim = rep(nrep, each = sum(n_list)),
      id = unlist(lapply(n_list, seq)),
      arm = unlist(as.list(mapply(rep, arm_names, n_list))),
      resp = unlist(as.list(mapply(rbinom, n_list, as.list(rep(1, n_arms)), prob_list)))
    )
    data_temp[, arm := factor(arm, levels = arm_names)]
    data_temp
  })

  stopCluster(cl)

  data <- rbindlist(results)
  freq <- freq_binary(data, n_list)

  return(list(data = data, true_value = rate_true, freq = freq))

}


