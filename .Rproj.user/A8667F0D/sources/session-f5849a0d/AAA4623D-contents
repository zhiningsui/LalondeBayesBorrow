#' Title
#'
#' @param endpoint A string. Type of endpoint (either "g-score" or "OR")
#' @param true_value A scalar. True median ratio for g-score endpoint or true rate difference for OR endpoint
#' @param post_est_ci A dataframe. Posterior inference obtained from bayesian_lalonde_decision(), including the posterior estimate, posterior standard error, and posterior 95% credible interval for each repetition
#'
#' @return A dataframe containing the evaluating metrics for posterior distribution, including the average bias, average standard error, empirical standard deviation, and nominal coverage probability. For g-score, more details can be found in eval_gscore_approx_dist()
#' @export
#'
#' @examples
calc_post_dist_metrics <- function(endpoint, true_value, post_est_ci) {
  if (endpoint == "g-score") {
    # Parameter of interest: log_delta = log(theta_t/theta_c)
    log_delta <- log(true_value)

    # Point estimate for each run: log_delta_hat = log(theta_t_hat) - log(theta_c_hat)
    log_delta_hat <- log(post_est_ci$est1) - log(post_est_ci$est2)

    # Average Bias of log_delta_hat
    bias_avg <- mean(log_delta_hat - log_delta)

    # Average Bias of estimated median ratio
    bias_avg_median_ratio1 <- exp(mean(log_delta_hat)) - true_value
    median_ratio_hat <- post_est_ci$est_compare
    bias_avg_median_ratio2 <- mean(median_ratio_hat - true_value)

    # Average SD (i.e., SE) of log_delta_hat
    sds <- post_est_ci$sd_compare
    sd_avg <- mean(sds)

    # Empirical SD of log_delta_hat
    sd_empirical <- sd(log_delta_hat)

    # Coverage probability 95%
    ci <- data.frame(cil = log(post_est_ci$compare_ci_l),
                     ciu = log(post_est_ci$compare_ci_u))
    ci$coverage <- ifelse(ci$cil < log_delta & ci$ciu > log_delta, 1, 0)
    cp <- mean(ci$coverage)

    metrics <- data.frame(log_delta = log_delta,
                          bias_avg = bias_avg,
                          bias_avg_median_ratio1 = bias_avg_median_ratio1,
                          bias_avg_median_ratio2 = bias_avg_median_ratio2,
                          sd_avg = sd_avg,
                          sd_empirical = sd_empirical,
                          cp = cp)

  } else if (endpoint == "OR") {
    # Parameter of interest: delta = rate_t - rate_c
    delta <- true_value

    # Point estimate for each run: delta_hat = rate_t_hat - rate_c_hat
    delta_hat <- post_est_ci$est_compare

    # Average Bias of estimated rate difference
    bias_avg_rate_diff <- mean(delta_hat - delta)

    # Average SD (i.e., SE) of delta_hat
    sds <- post_est_ci$sd_compare
    sd_avg <- mean(sds)

    # Empirical SD of delta_hat
    sd_empirical <- sd(delta_hat)

    # Coverage probability 95%
    ci <- data.frame(cil = post_est_ci$compare_ci_l,
                     ciu = post_est_ci$compare_ci_u)
    ci$coverage <- ifelse(ci$cil < delta & ci$ciu > delta, 1, 0)
    cp <- mean(ci$coverage)

    metrics <- data.frame(delta = delta,
                          bias_avg_rate_diff = bias_avg_rate_diff,
                          sd_avg = sd_avg,
                          sd_empirical = sd_empirical,
                          cp = cp)
  }

  return(metrics)
}



#' Title
#'
#' @param data A dataframe. Individual level binary endpoint outcomes (0/1)
#' @param n_list A list. Each object represents the number of patients in each arm
#'
#' @return A dataframe with each row representing the number of responses and the total number of patients in all arms in one repetition of simulation
#' @export
#'
#' @examples
freq_binary <- function(data, n_list) {
  freq <- data %>%
    group_by(nsim, arm, resp) %>%
    summarise(count = n(), .groups = 'drop') %>%
    ungroup() %>%
    complete(nsim, arm, resp, fill = list(count = 0)) %>%
    mutate(n = case_when(TRUE ~ n_list[as.integer(factor(arm, levels = levels(data$arm)))])) %>%
    filter(resp == 1) %>%
    group_by(nsim, arm) %>%
    summarise(n = unique(n), count = sum(count)) %>%
    pivot_wider(names_from = arm, values_from = c(n, count),names_glue = "{arm}.{.value}") %>%
    select(nsim, ends_with(".n"), ends_with(".count"))

  return(freq = freq)
}


#' Title
#'
#' @param env
#'
#' @return
#' @export
#'
#' @examples
get_all_functions <- function(env = environment()) {
  all_objects <- ls(env)
  functions <- sapply(all_objects, function(obj_name) is.function(get(obj_name, envir = env)))
  return(names(functions)[functions])
}


#' Title
#'
#' @param current
#' @param historical
#' @param endpoint
#' @param prior_params
#' @param arm
#'
#' @return
#' @export
#'
#' @examples
get_posterior_params <- function(current, historical, endpoint, prior_params, arm) {
  if (!is.null(current)) names(current) <- sapply(strsplit(names(current), "\\."), "[[", 2)
  if (!is.null(historical)) names(historical) <- sapply(strsplit(names(historical), "\\."), "[[", 2)

  if (endpoint == "g-score") {
    endpoint.1 = "continuous"
    if (!is.null(historical) && historical$log_median_sd == 0) historical$log_median_sd <- 0.000001
    if (current$log_median_sd == 0) current$log_median_sd <- 0.000001

    historical <- historical[, c("n", "log_median_adjusted", "log_median_sd")]
    current <- current[, c("n", "log_median_adjusted",  "log_median_sd")]

    if (!is.null(current))  names(current) <- c("n", "y", "s")
    if (!is.null(historical)) names(historical) <- c("n", "y", "s")

  } else if (endpoint == "OR"){
    endpoint.1 = "binary"
  }

  posterior_distribution(endpoint.1, current = current, historical = historical,
                         delta = prior_params[[paste0(arm, ".delta")]],
                         w = prior_params[[paste0(arm, ".w")]],
                         a = prior_params[[paste0(arm, ".a")]],
                         b = prior_params[[paste0(arm, ".b")]])
}

#' Generating to RBest mixture distribution
#'
#' This function generates a mixture distribution in the format of R package RBesT from a set of parameters of the mixture distribution.
#'
#' @param post A dataframe. Parameters for the mixture distribution, including the weight of each component and the distribution parameters for each component
#' @param endpoint A string. Type of endpoint (either "continuous" or "binary")
#'
#' @return A RBesT object of mixture distribution
#' @export
#'
#' @examples
convert_RBesT_mix <- function(post, endpoint){
  names(post) <- sapply(strsplit(gsub("_post", "", names(post)), "\\."), "[[", 2)
  if (endpoint == "continuous") {
    if(!is.data.frame(post)) post <- as.data.frame(t(post))
    # Define the normal mixture distributions using RBesT
    if (post$w == 0) {
      post = mixnorm(c(1-unname(post$w), unname(post$mu2), unname(post$sigma2)))
    } else if (post$w == 1){
      post = mixnorm(c(unname(post$w), unname(post$mu1), unname(post$sigma1)))
    }
    else {
      post = mixnorm(c(unname(post$w), unname(post$mu1), unname(post$sigma1)),
                     c(1-unname(post$w), unname(post$mu2), unname(post$sigma2)))
    }
  } else if (endpoint == "binary") {
    # Define the beta mixture distributions using RBesT
    if (post$w == 0) {
      post = mixbeta(c(1-unname(post$w), unname(post$a2), unname(post$b2)))
    } else if (post$w == 1){
      post = mixbeta(c(unname(post$w), unname(post$a1), unname(post$b1)))
    }else {
      post = mixbeta(c(unname(post$w), unname(post$a1), unname(post$b1)),
                     c(1-unname(post$w), unname(post$a2), unname(post$b2)))
    }
  }
  return(post)
}

#' Create Data Generation Parameters
#'
#' This function processes and validates a set of parameters for generating data
#' related to treatment and control groups, along with their historical counterparts.
#' It checks for missing values and replaces them with `NA` while issuing warnings.
#' The function supports different endpoints, and the interpretation of the `prob` parameter
#' varies depending on the specified endpoint:
#'   - For the "g-score" endpoint, `prob` refers to the probability of zero g-scores.
#'   - For the "OR" endpoint, `prob` may represent the probability of an event occurring.
#'
#' @param params A list containing the parameters for data generation.
#'   The list should include:
#'   - `trt_n` (numeric): Sample size for the treatment group.
#'   - `ctrl_n` (numeric): Sample size for the control group. If not provided, it will be set to match `trt_n`.
#'   - `trt_prob` (numeric): Probability for the treatment group, interpretation based on the `endpoint`.
#'   - `ctrl_prob` (numeric): Probability for the control group, interpretation based on the `endpoint`.
#'   - `trt_mu` (numeric): Mean value for the treatment group (for non-zero values in g-scores or other continuous endpoints).
#'   - `ctrl_mu` (numeric): Mean value for the control group.
#'   - `trt_sigma` (numeric): Standard deviation for the treatment group (for non-zero values in g-scores or other continuous endpoints).
#'   - `ctrl_sigma` (numeric): Standard deviation for the control group.
#'   - Additional parameters for historical data (e.g., `trt_h_n`, `ctrl_h_prob`) may also be included.
#' @param endpoint A string specifying the endpoint type. The meaning of the `prob` parameter
#'   depends on this value:
#'   - "g-score": `prob` refers to the probability of zero g-scores.
#'   - "OR": `prob` refers to the probability of an event occurring.
#'
#' @return A nested list containing the processed parameters for each group:
#'   - `treatment`: Parameters for the treatment group.
#'   - `control`: Parameters for the control group.
#'   - `treatment_h`: Parameters for the historical treatment group.
#'   - `control_h`: Parameters for the historical control group.
#'
#' Missing values are replaced with `NA` and a warning is issued for each missing parameter.
#'
#' @export
#'
#' @examples
#' # Example usage:
#' params <- list(trt_n = 100, trt_prob = 0.6, trt_mu = 1.5, trt_sigma = 0.3,
#'                ctrl_n = 100, ctrl_prob = 0.4, ctrl_mu = 1.2, ctrl_sigma = 0.2)
#' create_data_gen_params(params, "g-score")
#'
create_data_gen_params <- function(params, endpoint) {
  check_param <- function(param, param_name) {
    if (!is.null(param)) {
      return(param)
    } else {
      warning(paste("Warning: Parameter", param_name, "is missing. Replacing with NA."))
      return(NA)
    }
  }
  safe_log <- function(param, param_name) {
    if (!is.null(param)) {
      return(log(param))
    } else {
      warning(paste("Warning: Parameter", param_name, "is missing. Replacing with NA."))
      return(NA)
    }
  }
  param_list <- list(
    treatment = list(
      n = check_param(params$trt_n, "trt_n"),
      prob = check_param(params$trt_prob, "trt_prob"),
      mu = safe_log(params$trt_mu, "trt_mu"),
      sigma = check_param(params$trt_sigma, "trt_sigma"),
      name = "treatment"
    ),
    control = list(
      n = check_param(params$ctrl_n, "ctrl_n"),
      prob = check_param(params$ctrl_prob, "ctrl_prob"),
      mu = safe_log(params$ctrl_mu, "ctrl_mu"),
      sigma = check_param(params$ctrl_sigma, "ctrl_sigma"),
      name = "control"
    ),
    treatment_h = list(
      n = check_param(params$trt_h_n, "trt_h_n"),
      prob = check_param(params$trt_h_prob, "trt_h_prob"),
      mu = safe_log(params$trt_h_mu, "trt_h_mu"),
      sigma = check_param(params$trt_h_sigma, "trt_h_sigma"),
      name = "treatment_h"
    ),
    control_h = list(
      n = check_param(params$ctrl_h_n, "ctrl_h_n"),
      prob = check_param(params$ctrl_h_prob, "ctrl_h_prob"),
      mu = safe_log(params$ctrl_h_mu, "ctrl_h_mu"),
      sigma = check_param(params$ctrl_h_sigma, "ctrl_h_sigma"),
      name = "control_h"
    )
  )
  # Filter out entries with missing n or prob parameters
  if(endpoint == "g-score"){
    param_list_filtered <- Filter(function(x) !any(sapply(x, is.na)), param_list)
  } else if (endpoint == "OR"){
    param_list_filtered <- Filter(function(x) !any(sapply(x[c("n", "prob")], is.na)), param_list)
  }

  return(param_list_filtered)
}



